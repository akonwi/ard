# FFI Code Generation Plan

## Context

**Current State**: FFI system is working with manual function registration in `vm/ffi_registry.go`:

```go
// Manual registration - what we want to eliminate
registry.functions["runtime.go_print"] = go_print
registry.functions["runtime.go_read_line"] = go_read_line
```

**Problem**: Manual registration doesn't scale well and violates DRY principle. Adding new FFI functions requires:
1. Implementing the function 
2. Manually adding registry entry
3. Risk of forgetting step 2 or typos in binding names

**Goal**: Eliminate manual registration while maintaining zero runtime overhead and clean file organization.

## Proposed Solution: Build-Time Code Generation

Use Go's `go generate` to automatically discover FFI functions and generate registration code at build time.

### Target File Organization

```
vm/ffi/
├── generate.go          # Code generator
├── registry.gen.go      # Generated registration (gitignored)
├── runtime.go           # go_print, go_read_line
├── fs.go               # go_read_file, go_write_file
├── net.go              # go_http_send, go_tcp_connect
└── math.go             # go_sqrt, go_sin, go_cos
```

### Code Generation Process

1. **Discovery**: Parse all `.go` files in `vm/ffi/` directory
2. **Validation**: Check that functions match FFI signature: `func(vm *VM, args []*object) (*object, error)`
3. **Generation**: Create `registry.gen.go` with automatic registration
4. **Integration**: Generated code uses existing `RegisterFFIModule()` pattern

### Implementation Details

#### Generator (`vm/ffi/generate.go`)

```go
//go:generate go run generate.go

package main

import (
    "go/ast"
    "go/parser" 
    "go/token"
    "path/filepath"
    "text/template"
)

func main() {
    functions := discoverFFIFunctions(".")
    generateRegistry(functions)
}

func discoverFFIFunctions(dir string) map[string][]string {
    // Walk directory, parse Go files, extract FFI functions
    // Return map[module][]functions
}

func parseFFIFunctions(filename string) []string {
    // Parse AST, find functions matching FFI signature
    // Return list of function names
}

func isFFIFunction(fn *ast.FuncDecl) bool {
    // Validate signature: func(vm *VM, args []*object) (*object, error)
    // Return true if matches
}

func generateRegistry(modules map[string][]string) {
    // Generate registry.gen.go using template
}
```

#### Generated Output (`vm/ffi/registry.gen.go`)

```go
// Code generated by go generate; DO NOT EDIT.
package ffi

func init() {
    RegisterFFIModule("runtime", map[string]FFIFunc{
        "go_print":     go_print,
        "go_read_line": go_read_line,
    })
    
    RegisterFFIModule("fs", map[string]FFIFunc{
        "go_read_file":  go_read_file,
        "go_write_file": go_write_file,
    })
    
    RegisterFFIModule("math", map[string]FFIFunc{
        "go_sqrt": go_sqrt,
        "go_sin":  go_sin,
        "go_cos":  go_cos,
    })
}
```

## Benefits

✅ **Zero Runtime Overhead**: All resolution happens at build time  
✅ **Automatic Discovery**: Just add function to appropriate file  
✅ **Build-Time Validation**: Ensures correct signatures before compilation  
✅ **Clean Organization**: Functions grouped by logical modules  
✅ **No Manual Registration**: Completely eliminates error-prone manual steps  
✅ **Scalable**: Easy to add new modules and functions  
✅ **IDE Friendly**: Generated code provides autocomplete and navigation  

## Migration Plan

### Phase 1: Set Up Code Generation Infrastructure
1. Create `vm/ffi/` directory structure
2. Move existing functions from `vm/ffi_functions.go` to module files:
   - `go_print`, `go_read_line` → `vm/ffi/runtime.go`
   - Future: math functions → `vm/ffi/math.go`
3. Implement `generate.go` with FFI function discovery
4. Add `//go:generate` directive
5. Test generation produces correct output

### Phase 2: Replace Manual Registration
1. Remove manual registration from `vm/ffi_registry.go`
2. Update build process to run `go generate ./vm/ffi` 
3. Verify all existing FFI calls still work
4. Update documentation and developer workflow

### Phase 3: Expand Module Coverage
1. Create additional module files as needed:
   - `vm/ffi/fs.go` - File system operations
   - `vm/ffi/net.go` - Network operations  
   - `vm/ffi/crypto.go` - Cryptographic functions
2. Each new function automatically discovered and registered

## Developer Workflow

Adding a new FFI function becomes:

1. **Add function to appropriate module file**:
   ```go
   // vm/ffi/runtime.go
   func go_new_function(vm *VM, args []*object) (*object, error) {
       // Implementation
   }
   ```

2. **Regenerate registry**:
   ```bash
   go generate ./vm/ffi
   ```

3. **Use in Ard standard library**:
   ```ard
   // std_lib/some_module.ard
   extern fn new_function() Void = "runtime.go_new_function"
   ```

**That's it!** No manual registration required.

## Technical Considerations

### Signature Validation
The generator must validate that functions match the exact FFI signature:
```go
func functionName(vm *VM, args []*object) (*object, error)
```

Invalid signatures should cause build-time errors with helpful messages.

### Module Naming Convention
- File name determines module: `runtime.go` → `"runtime"` module
- Function binding: `"runtime.go_print"` calls `go_print` from `runtime.go`
- Keep existing naming for backward compatibility

### Build Integration
- Add `//go:generate go run generate.go` to `vm/ffi/` package
- Include generation step in main build process
- Consider pre-commit hooks to ensure registry is up-to-date

### Error Handling
- Generator should fail fast on invalid signatures
- Provide clear error messages for debugging
- Include file and line number information

## Future Enhancements

### Validation Extensions
- Check that referenced bindings in `.ard` files have corresponding Go implementations
- Validate parameter count and types match between Ard declarations and Go signatures
- Generate warnings for unused FFI functions

### Documentation Generation
- Auto-generate documentation from Go function comments
- Create mapping between Ard declarations and Go implementations
- Generate developer-friendly FFI function reference

### IDE Integration
- Generate stub functions for missing implementations
- Provide autocomplete for available FFI bindings
- Navigate from Ard declarations to Go implementations

## Conclusion

This code generation approach eliminates the maintenance burden of manual FFI registration while preserving the performance and safety benefits of the current system. It scales naturally as new standard library modules are added and provides a excellent developer experience.

The generated code is deterministic, fast, and integrates seamlessly with the existing FFI infrastructure.
