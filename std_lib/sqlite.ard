use ard/decode
use ard/maybe
use ard/result as Result

type Value = Str | Bool | Int | Float | Void

private extern fn _create_connection(filepath: Str) Dynamic!Str = "SqliteCreateConnection"
private extern fn _close(conn: Dynamic) Void!Str = "SqliteClose"
private extern fn _exec(conn: Dynamic, sql: Str) Void!Str = "SqliteExec"
private extern fn _query_run(conn: Dynamic, sql: Str, values: [Value]) Void!Str = "SqliteQueryRun"
private extern fn _query_all(conn: Dynamic, sql: Str, values: [Value]) [Dynamic]!Str = "SqliteQuery"
private extern fn _first(conn: Dynamic, sql: Str) Dynamic!Str = "SqliteFirst"
private extern fn _insert(conn: Dynamic, table: Str, values: [Str:Dynamic]) Dynamic!Str = "SqliteInsert"
private extern fn _update(conn: Dynamic, table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str = "SqliteUpdate"
private extern fn _delete(conn: Dynamic, table: Str, where: Str) Bool!Str = "SqliteDelete"
private extern fn _count(conn: Dynamic, table: Str, where: Str) Int!Str = "SqliteCount"

extern fn extract_params(sql: Str) [Str] = "SqliteExtractParams"

struct Query {
  conn: Dynamic,
  string: Str,
  params: [Str]
}

impl Query {
  fn prepare(mut query_str: Str, mut values: [Value], args: [Str:Value]) Void!Str {
    for param in @params {
      query_str = query_str.replace_all("@"+param, "?")
      let value = try args.get(param) -> _ { Result::err("Missing parameter: " + param) }
      values.push(value)
    }

    Result::ok(())
  }

  fn run(args: [Str:Value]) Void!Str {
    mut sanitized = @string
    mut values: [Value] = []
    try @prepare(sanitized, values, args)
    _query_run(@conn, sanitized, values)
  }

  fn all(args: [Str:Value]) [Dynamic]!Str {
    mut sanitized = @string
    mut values: [Value] = []
    try @prepare(sanitized, values, args)
    _query_all(@conn, sanitized, values)
  }

  fn first(args: [Str:Value]) Dynamic?!Str {
    let rows = try @all(args)
    match rows.size() {
      0 => Result::ok(maybe::none()),
      _ => Result::ok(maybe::some(rows.at(0)))
    }
  }
}

struct Database {
  conn: Dynamic
  filepath: Str
}

fn open(filepath: Str) Database!Str {
  let conn = try _create_connection(filepath)
  Result::ok(Database{ conn: conn, filepath: filepath })
}

impl Database {
  fn close() Void!Str {
    _close(@conn)
  }

  fn exec(sql: Str) Void!Str {
    _exec(@conn, sql)
  }

  fn query(sql: Str) Query {
    Query{
      conn: @conn,
      string: sql,
      params: extract_params(sql),
    }
  }

  fn first(sql: Str) Dynamic!Str {
    _first(@conn, sql)
  }

  fn insert(table: Str, values: [Str:Dynamic]) Dynamic!Str {
    _insert(@conn, table, values)
  }

  fn update(table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str {
    _update(@conn, table, where, values)
  }

  fn delete(table: Str, where: Str) Bool!Str {
    _delete(@conn, table, where)
  }

  fn count(table: Str, where: Str) Int!Str {
    _count(@conn, table, where)
  }

  fn exists(table: Str, where: Str) Bool!Str {
    let count = try @count(table, where)
    Result::ok(count > 0)
  }

  fn upsert(table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str {
    let found = try @exists(table, where)
    match found {
      true => @update(table, where, values),
      false => @insert(table, values)
    }
  }
}
