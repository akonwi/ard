use ard/decode

extern fn extract_params(sql: Str) [Str] = "SqliteExtractParams"
private extern fn _create_connection(filepath: Str) Dynamic!Str = "SqliteCreateConnection"
private extern fn _close(conn: Dynamic) Void!Str = "SqliteClose"
private extern fn _exec(conn: Dynamic, sql: Str) Void!Str = "SqliteExec"
private extern fn _query(conn: Dynamic, sql: Str) Dynamic!Str = "SqliteQuery"
private extern fn _first(conn: Dynamic, sql: Str) Dynamic!Str = "SqliteFirst"
private extern fn _insert(conn: Dynamic, table: Str, values: [Str:Dynamic]) Dynamic!Str = "SqliteInsert"
private extern fn _update(conn: Dynamic, table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str = "SqliteUpdate"
private extern fn _delete(conn: Dynamic, table: Str, where: Str) Bool!Str = "SqliteDelete"
private extern fn _count(conn: Dynamic, table: Str, where: Str) Int!Str = "SqliteCount"

struct Database {
  conn: Dynamic
  filepath: Str
}

fn open(filepath: Str) Database!Str {
  let conn = try _create_connection(filepath)
  Result::ok(Database{ conn: conn, filepath: filepath })
}

impl Database {
  fn close() Void!Str {
    _close(@conn)
  }

  fn exec(sql: Str) Void!Str {
    _exec(@conn, sql)
  }

  fn query(sql: Str) Dynamic!Str {
    _query(@conn, sql)
  }

  fn first(sql: Str) Dynamic!Str {
    _first(@conn, sql)
  }

  fn insert(table: Str, values: [Str:Dynamic]) Dynamic!Str {
    _insert(@conn, table, values)
  }

  fn update(table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str {
    _update(@conn, table, where, values)
  }

  fn delete(table: Str, where: Str) Bool!Str {
    _delete(@conn, table, where)
  }

  fn count(table: Str, where: Str) Int!Str {
    _count(@conn, table, where)
  }

  fn exists(table: Str, where: Str) Bool!Str {
    let count = try @count(table, where)
    Result::ok(count > 0)
  }

  fn upsert(table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str {
    let found = try @exists(table, where)
    match found {
      true => @update(table, where, values),
      false => @insert(table, values)
    }
  }
}
