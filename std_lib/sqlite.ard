use ard/decode

type Value = Str | Bool | Int | Float

private extern fn _create_connection(filepath: Str) Dynamic!Str = "SqliteCreateConnection"
private extern fn _close(conn: Dynamic) Void!Str = "SqliteClose"
private extern fn _exec(conn: Dynamic, sql: Str) Void!Str = "SqliteExec"
private extern fn _query_run(conn: Dynamic, sql: Str, values: [Dynamic]) Dynamic!Str = "SqliteQueryRun"
private extern fn _query_all(conn: Dynamic, sql: Str, values: [Value?]) Dynamic!Str = "SqliteQuery"
private extern fn _first(conn: Dynamic, sql: Str) Dynamic!Str = "SqliteFirst"
private extern fn _insert(conn: Dynamic, table: Str, values: [Str:Dynamic]) Dynamic!Str = "SqliteInsert"
private extern fn _update(conn: Dynamic, table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str = "SqliteUpdate"
private extern fn _delete(conn: Dynamic, table: Str, where: Str) Bool!Str = "SqliteDelete"
private extern fn _count(conn: Dynamic, table: Str, where: Str) Int!Str = "SqliteCount"

extern fn extract_params(sql: Str) [Str] = "SqliteExtractParams"

struct Query {
  conn: Dynamic,
  string: Str,
  params: [Str]
}

impl Query {
  fn run(values: [Str:Dynamic]) Dynamic!Str {
    mut sanitized = @string
    mut ordered_values: [Dynamic] = []
    for param in @params {
      sanitized = sanitized.replace_all("@"+param, "?")
      let value = try values.get(param) -> _ { Result::err("Missing parameter: " + param) }
      ordered_values.push(value)
    }

    _query_run(@conn, sanitized, ordered_values)
  }

  fn all(values: [Str:Value?]) Dynamic!Str {
    mut sanitized = @string
    mut ordered_values: [Value?] = []
    for param in @params {
      sanitized = sanitized.replace_all("@"+param, "?")
      let value = try values.get(param) -> _ { Result::err("Missing parameter: " + param) }
      ordered_values.push(value)
    }

    _query_all(@conn, sanitized, ordered_values)
  }
}

struct Database {
  conn: Dynamic
  filepath: Str
}

fn open(filepath: Str) Database!Str {
  let conn = try _create_connection(filepath)
  Result::ok(Database{ conn: conn, filepath: filepath })
}

impl Database {
  fn close() Void!Str {
    _close(@conn)
  }

  fn exec(sql: Str) Void!Str {
    _exec(@conn, sql)
  }

  fn query(sql: Str) Query {
    Query{
      conn: @conn,
      string: sql,
      params: extract_params(sql),
    }
  }

  fn first(sql: Str) Dynamic!Str {
    _first(@conn, sql)
  }

  fn insert(table: Str, values: [Str:Dynamic]) Dynamic!Str {
    _insert(@conn, table, values)
  }

  fn update(table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str {
    _update(@conn, table, where, values)
  }

  fn delete(table: Str, where: Str) Bool!Str {
    _delete(@conn, table, where)
  }

  fn count(table: Str, where: Str) Int!Str {
    _count(@conn, table, where)
  }

  fn exists(table: Str, where: Str) Bool!Str {
    let count = try @count(table, where)
    Result::ok(count > 0)
  }

  fn upsert(table: Str, where: Str, values: [Str:Dynamic]) Dynamic!Str {
    let found = try @exists(table, where)
    match found {
      true => @update(table, where, values),
      false => @insert(table, values)
    }
  }
}
