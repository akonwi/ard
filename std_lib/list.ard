use ard/maybe

extern fn new() [$T] = "NewList"

fn concat(a: [$T], b: [$T]) [$T] {
  mut res = a
  for i in b {
    res.push(i)
  }
  res
}

// returns a new list of the items, dropping the elements before the given index
fn drop(from: [$T], till: Int) [$T] {
  mut out: [$T] = []
  for t, idx in from {
    if idx >= till {
      out.push(t)
    }
  }

  out
}

// given a list of items and a predicate, returns a new list of items matching the predicate
fn keep(list: [$T], where: fn($T) Bool) [$T] {
  mut out: [$T] = []
  for t in list {
    if where(t) {
      out.push(t)
    }
  }

  out
}

// transforms a list of items using a given function
fn map(list: [$A], transform: fn($A) $B) [$B] {
  mut out: [$B] = []
  for t in list {
    out.push(transform(t))
  }

  out
}

// look for the first item in a list matching the predicate
fn find(list: [$T], where: fn($T) Bool) $T? {
  mut found = maybe::none<$T>()
  for t in list {
    if where(t) {
      found = maybe::some(t)
      break
    }
  }

  found
}

// split a list into two based on which match the given predicate
struct Partition {
  selected: [$T],
  others: [$T],
}

fn partition(list: [$T], where: fn($T) Bool) Partition<$T> {
  mut selected: [$T] = []
  mut others: [$T] = []

  for t in list {
    match where(t) {
      true => selected.push(t),
      false => others.push(t)
    }
  }

  Partition{ selected: selected, others: others }
}
