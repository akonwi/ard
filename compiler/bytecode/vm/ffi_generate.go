//go:build ignore

package main

import (
	"fmt"
	"go/ast"
	goparser "go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type FFIFunction struct {
	Name   string
	Module string
	File   string
}

func main() {
	ffiDir := "../../ffi"
	functions, err := discoverFFIFunctions(ffiDir)
	if err != nil {
		log.Fatalf("Failed to discover FFI functions: %v", err)
	}

	if err := generateRegistry(functions); err != nil {
		log.Fatalf("Failed to generate registry: %v", err)
	}

	fmt.Printf("Generated registry with %d FFI functions\n", len(functions))
}

func discoverFFIFunctions(dir string) ([]FFIFunction, error) {
	var functions []FFIFunction

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() || !strings.HasSuffix(path, ".go") {
			return nil
		}

		if strings.HasSuffix(path, "ffi_generate.go") || strings.HasSuffix(path, ".gen.go") {
			return nil
		}

		fileFunctions, err := parseFFIFunctions(path)
		if err != nil {
			return fmt.Errorf("failed to parse %s: %w", path, err)
		}

		functions = append(functions, fileFunctions...)
		return nil
	})

	return functions, err
}

func parseFFIFunctions(filename string) ([]FFIFunction, error) {
	fset := token.NewFileSet()
	node, err := goparser.ParseFile(fset, filename, nil, goparser.ParseComments)
	if err != nil {
		return nil, err
	}

	var functions []FFIFunction

	base := filepath.Base(filename)
	if !strings.HasSuffix(base, ".go") {
		return functions, nil
	}
	module := strings.TrimSuffix(base, ".go")

	ast.Inspect(node, func(n ast.Node) bool {
		if fn, ok := n.(*ast.FuncDecl); ok {
			if isFFIFunction(fn) {
				functions = append(functions, FFIFunction{
					Name:   fn.Name.Name,
					Module: module,
					File:   filename,
				})
			}
		}
		return true
	})

	return functions, nil
}

func isFFIFunction(fn *ast.FuncDecl) bool {
	if strings.HasPrefix(fn.Name.Name, "_") {
		return false
	}

	if fn.Type.Params == nil || len(fn.Type.Params.List) != 2 {
		return false
	}

	if fn.Type.Results == nil || len(fn.Type.Results.List) != 1 {
		return false
	}

	firstParam := fn.Type.Params.List[0]
	if !isSliceOfPointerToRuntimeObject(firstParam.Type) {
		return false
	}

	secondParam := fn.Type.Params.List[1]
	if sel, isSelector := secondParam.Type.(*ast.SelectorExpr); isSelector {
		pkg, ok := sel.X.(*ast.Ident)
		return ok && pkg.Name == "checker" && sel.Sel.Name == "Type"
	}

	firstReturn := fn.Type.Results.List[0]
	if !isPointerToRuntimeObject(firstReturn.Type) {
		return false
	}

	return true
}

func isPointerToRuntimeObject(expr ast.Expr) bool {
	star, ok := expr.(*ast.StarExpr)
	if !ok {
		return false
	}

	sel, ok := star.X.(*ast.SelectorExpr)
	if ok {
		pkg, ok := sel.X.(*ast.Ident)
		return ok && pkg.Name == "runtime" && sel.Sel.Name == "Object"
	}

	ident, ok := star.X.(*ast.Ident)
	return ok && ident.Name == "Object"
}

func isSliceOfPointerToRuntimeObject(expr ast.Expr) bool {
	array, ok := expr.(*ast.ArrayType)
	if !ok {
		return false
	}
	return isPointerToRuntimeObject(array.Elt)
}

func generateRegistry(functions []FFIFunction) error {
	var sb strings.Builder

	sb.WriteString(`// Code generated by generate.go; DO NOT EDIT.

package vm

import (
	"fmt"

	"github.com/akonwi/ard/ffi"
)

// RegisterGeneratedFFIFunctions registers all discovered FFI functions
func (r *RuntimeFFIRegistry) RegisterGeneratedFFIFunctions() error {
`)

	for _, fn := range functions {
		binding := fn.Name
		functionRef := fmt.Sprintf("ffi.%s", fn.Name)
		sb.WriteString(fmt.Sprintf("\tif err := r.Register(%q, %s); err != nil {\n", binding, functionRef))
		sb.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"failed to register %s: %%w\", err)\n", binding))
		sb.WriteString("\t}\n")
	}

	sb.WriteString(`
	return nil
}
`)

	return os.WriteFile("registry.gen.go", []byte(sb.String()), 0644)
}
