//go:build ignore

package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"strings"
)

// FFIFunction represents a discovered FFI function
type FFIFunction struct {
	Name   string
	Module string
	File   string
}

func main() {
	// Find all Go files in vm directory
	vmDir := "."
	functions, err := discoverFFIFunctions(vmDir)
	if err != nil {
		log.Fatalf("Failed to discover FFI functions: %v", err)
	}

	// Generate the registry file
	if err := generateRegistry(functions); err != nil {
		log.Fatalf("Failed to generate registry: %v", err)
	}

	fmt.Printf("Generated registry with %d FFI functions\n", len(functions))
}

// discoverFFIFunctions scans Go files for FFI function signatures
func discoverFFIFunctions(dir string) ([]FFIFunction, error) {
	var functions []FFIFunction

	err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		// Skip generate.go and generated files
		if strings.HasSuffix(path, "ffi_generate.go") || strings.HasSuffix(path, ".gen.go") {
			return nil
		}

		if !strings.HasSuffix(path, ".go") || info.IsDir() {
			return nil
		}

		fileFunctions, err := parseFFIFunctions(path)
		if err != nil {
			return fmt.Errorf("failed to parse %s: %w", path, err)
		}

		functions = append(functions, fileFunctions...)
		return nil
	})

	return functions, err
}

// parseFFIFunctions parses a Go file and extracts FFI functions
func parseFFIFunctions(filename string) ([]FFIFunction, error) {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
	if err != nil {
		return nil, err
	}

	var functions []FFIFunction
	modulePattern := regexp.MustCompile(`^ffi_([a-z]+)\.go$`)

	// Extract module name from filename
	base := filepath.Base(filename)
	matches := modulePattern.FindStringSubmatch(base)
	if len(matches) < 2 {
		return functions, nil // Skip files that don't match ffi_ pattern
	}
	module := matches[1]

	// Walk the AST to find FFI functions
	ast.Inspect(node, func(n ast.Node) bool {
		if fn, ok := n.(*ast.FuncDecl); ok {
			if isFFIFunction(fn) {
				functions = append(functions, FFIFunction{
					Name:   fn.Name.Name,
					Module: module,
					File:   filename,
				})
			}
		}
		return true
	})

	return functions, nil
}

// isFFIFunction checks if a function matches the FFI signature
func isFFIFunction(fn *ast.FuncDecl) bool {
	// Check if function is exported (starts with lowercase go_ prefix)
	if !strings.HasPrefix(fn.Name.Name, "go_") {
		return false
	}

	// Check function signature: func(vm *VM, args []*object) (*object, error)
	if fn.Type.Params == nil || len(fn.Type.Params.List) != 2 {
		return false
	}

	if fn.Type.Results == nil || len(fn.Type.Results.List) != 2 {
		return false
	}

	// Validate first parameter: vm *VM
	firstParam := fn.Type.Params.List[0]
	if len(firstParam.Names) != 1 || firstParam.Names[0].Name != "vm" {
		return false
	}
	if !isPointerToType(firstParam.Type, "VM") {
		return false
	}

	// Validate second parameter: args []*object
	secondParam := fn.Type.Params.List[1]
	if len(secondParam.Names) != 1 || secondParam.Names[0].Name != "args" {
		return false
	}
	if !isSliceOfPointerToType(secondParam.Type, "object") {
		return false
	}

	// Validate return types: (*object, error)
	firstReturn := fn.Type.Results.List[0]
	if !isPointerToType(firstReturn.Type, "object") {
		return false
	}

	secondReturn := fn.Type.Results.List[1]
	if !isErrorType(secondReturn.Type) {
		return false
	}

	return true
}

// Helper functions for AST type checking
func isPointerToType(expr ast.Expr, typeName string) bool {
	star, ok := expr.(*ast.StarExpr)
	if !ok {
		return false
	}
	ident, ok := star.X.(*ast.Ident)
	return ok && ident.Name == typeName
}

func isSliceOfPointerToType(expr ast.Expr, typeName string) bool {
	array, ok := expr.(*ast.ArrayType)
	if !ok {
		return false
	}
	return isPointerToType(array.Elt, typeName)
}

func isErrorType(expr ast.Expr) bool {
	ident, ok := expr.(*ast.Ident)
	return ok && ident.Name == "error"
}

// generateRegistry creates the registry.gen.go file
func generateRegistry(functions []FFIFunction) error {
	var sb strings.Builder

	sb.WriteString(`// Code generated by generate.go; DO NOT EDIT.

package vm

import "fmt"

// RegisterGeneratedFFIFunctions registers all discovered FFI functions
func (r *RuntimeFFIRegistry) RegisterGeneratedFFIFunctions() error {
`)

	for _, fn := range functions {
		binding := fmt.Sprintf("%s.%s", fn.Module, fn.Name)
		sb.WriteString(fmt.Sprintf("\tif err := r.Register(%q, %s); err != nil {\n", binding, fn.Name))
		sb.WriteString(fmt.Sprintf("\t\treturn fmt.Errorf(\"failed to register %s: %%w\", err)\n", binding))
		sb.WriteString("\t}\n")
	}

	sb.WriteString(`
	return nil
}
`)

	return os.WriteFile("registry.gen.go", []byte(sb.String()), 0644)
}
